<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Place</title>
    <!-- the share feature is broken, but I got it to work:
     https://chatgpt.com/share/05cf1a3e-e302-45fb-a69f-f87221628afa
     https://chatgpt.com/share/67f2d0f5-94c7-4f07-81f5-264eb229c298
     https://chatgpt.com/share/89eb18cd-237a-4cea-88d2-a92c7ce6afe0
    -->
    <script>
        // *Change this to the correct URL
        const ws = new WebSocket('ws://localhost:8080');
        const tileColors = {};
        var canvasSize = 50;
        var rateLimit = -1;
        ws.onmessage = (event) => {
            // Is it a number?
            if (!isNaN(event.data)) {
                if (rateLimit === -1) {
                    rateLimit = parseInt(event.data);
                    return;
                }
                canvasSize = parseInt(event.data);
                return;
            }
            const data = JSON.parse(event.data);
            tileColors[`${data.x},${data.y}`] = data.color;
            //drawGrid();
            // *And here I was writing a complex binary parser to convert 4-byte integers to pixel coordinates and turning a byte into a colour
        };
        ws.onclose = () => {
            // *Not well-implimented
            location.reload();
        };
        // Authenticate the user
        ws.onopen = () => {
            ws.send(window.location.hash.substring(window.location.hash.indexOf('access_token=') + 13).split('&')[0].split('/')[0]);
        };
        window.location.hash = '';
        var canvas;
        var chosenColor = null;
        var ctx;
        const tileSize = 20;
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let selectedTile = null;
        const keysPressed = {};
        const velocity = { x: 0, y: 0 };
        const maxSpeed = 10;
        const acceleration = 0.4;
        const deceleration = 0.8;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            //drawGrid();
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cols = Math.ceil(canvas.width / (tileSize * zoom)) + 2;
            const rows = Math.ceil(canvas.height / (tileSize * zoom)) + 2;
            const startX = Math.floor(offsetX) - Math.floor(cols / 2);
            const startY = Math.floor(offsetY) - Math.floor(rows / 2);

            // *Meme Tech update: ChatGPT was drawing lines individually, which was slow, so I'm setting the BG to black in advance
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // *Meme Tech update (again): I noticed some heavy calculation in a hefty loop here, so I'm variable-ify-ing it
            var tileSizeTimesZoom = tileSize * zoom;
            //var tileSizeTimesZoomMinusOne = tileSizeTimesZoom - 1;
            //var tileSizeTimesZoomMinusOne = tileSize * (zoom - 1);
            var tileSizeTimesZoomMinusOne = (tileSize - 1) * zoom;
            //if (Math.abs(tileSizeTimesZoomMinusOne - tileSizeTimesZoom) < 2) {
            //    tileSizeTimesZoomMinusOne = tileSizeTimesZoom; // *Meme Tech note: Remove outline when zoomed out enough for it to cause issues
            //}
            //var floorColsDiv2 = Math.floor(cols / 2);
            //var floorRowsDiv2 = Math.floor(rows / 2);
            // *Meme Tech idea: Isn't that just a bit shift?
            var floorColsDiv2 = cols >> 1;
            var floorRowsDiv2 = rows >> 1;

            //const canvasSize = 100

            for (let x = startX; x < startX + cols; x++) {
                for (let y = startY; y < startY + rows; y++) {
                    // *Meme Tech update (yet again): I decided to make the canvas only white within 1000 pixels of the center
                    //const color = tileColors[`${x},${y}`] || '#ffffff';
                    const color = tileColors[`${x},${y}`] || (((Math.abs(x) < canvasSize) && (Math.abs(y) < canvasSize)) ? '#ffffff' : '#000000');
                    ctx.fillStyle = color;
                    const drawX = (x - offsetX + floorColsDiv2) * tileSizeTimesZoom;
                    const drawY = (y - offsetY + floorRowsDiv2) * tileSizeTimesZoom;
                    //ctx.fillRect(drawX, drawY, tileSize * zoom, tileSize * zoom);
                    ctx.fillRect(drawX, drawY, tileSizeTimesZoomMinusOne, tileSizeTimesZoomMinusOne);
                    //ctx.strokeStyle = '#cccccc';
                    //ctx.strokeRect(drawX, drawY, tileSize * zoom, tileSize * zoom);
                }
            }
        }

        function handleTileClick(x, y, mouseX, mouseY) {
            //selectedTile = { x, y };
            // *Meme Tech update: IT'S OFF!
            //selectedTile = { x: x - 1, y: y - 2 };
            if (chosenColor) {
                //const { x, y } = selectedTile;
                const confirmChange = confirm("Change the tile colour?");
                if (confirmChange) {
                    //tileColors[`${x-1},${y-2}`] = chosenColor; // *Meme Tech note: IT'S STILL OFF! (I have no idea why, but this fix works when fully zoomed in, so it's fine)
                    ws.send(JSON.stringify({ x: x - 1, y: y - 2, color: chosenColor }));
                    // Here you can add code to start the 5-minute timer
                }
                //drawGrid();
            }
        }

        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        function updateOffset() {
            if (keysPressed['ArrowUp'] && !keysPressed['ArrowDown']) {
                velocity.y = Math.max(velocity.y - acceleration, -maxSpeed);
            } else if (keysPressed['ArrowDown'] && !keysPressed['ArrowUp']) {
                velocity.y = Math.min(velocity.y + acceleration, maxSpeed);
            } else {
                velocity.y = Math.abs(velocity.y) < deceleration ? 0 : velocity.y + (velocity.y > 0 ? -deceleration : deceleration);
            }

            if (keysPressed['ArrowLeft'] && !keysPressed['ArrowRight']) {
                velocity.x = Math.max(velocity.x - acceleration, -maxSpeed);
            } else if (keysPressed['ArrowRight'] && !keysPressed['ArrowLeft']) {
                velocity.x = Math.min(velocity.x + acceleration, maxSpeed);
            } else {
                velocity.x = Math.abs(velocity.x) < deceleration ? 0 : velocity.x + (velocity.x > 0 ? -deceleration : deceleration);
            }

            offsetX += velocity.x / (tileSize * zoom);
            offsetY += velocity.y / (tileSize * zoom);
        }

        function animate() {
            updateOffset();
            drawGrid();
            requestAnimationFrame(animate);
            // *Meme Tech update: Let's add the x, y and zoom to the hash
            window.location.hash = (offsetX || offsetY || zoom) ? `#x=${offsetX}&y=${offsetY}&zoom=${zoom}` : '';
        }

        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            if (e.deltaY > 0) {
                zoom /= zoomFactor;
            } else {
                zoom *= zoomFactor;
            }
            zoom = Math.max(0.1, Math.min(zoom, 10)); // Limit zoom levels
            //drawGrid();
        });

        window.addEventListener('resize', resizeCanvas);

        // Prevent default scrolling behavior
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        function selectColour(button) {
            const buttons = document.querySelectorAll('button');
            buttons.forEach((button) => {
                button.classList.remove('selected');
            });
            button.classList.add('selected');
            //chosenColor = button.style.backgroundColor;
            // backgroundColor is empty, so we use the id
            switch (button.id) {
                case 'red':
                    chosenColor = '#ff0000';
                    break;
                case 'green':
                    chosenColor = '#00ff00';
                    break;
                case 'blue':
                    chosenColor = '#0000ff';
                    break;
                case 'yellow':
                    chosenColor = '#ffff00';
                    break;
                case 'purple':
                    chosenColor = '#ff00ff';
                    break;
                case 'cyan':
                    chosenColor = '#00ffff';
                    break;
                case 'white':
                    chosenColor = '#ffffff';
                    break;
                case 'black':
                    chosenColor = '#000000';
                    break;
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #eee;
        }
        #colours {
            position: absolute;
            display: none;
        }
        canvas {
            display: block;
        }
        button {
            width: 5vh;
            height: 5vh;
            margin: 0.5vh;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.1s;
        }
        #red {
            background-color: #ff0000;
            border: 0.5vh solid #aa0000;
        }
        #green {
            background-color: #00ff00;
            border: 0.5vh solid #00aa00;
        }
        #blue {
            background-color: #0000ff;
            border: 0.5vh solid #0000aa;
        }
        #yellow {
            background-color: #ffff00;
            border: 0.5vh solid #aaaa00;
        }
        #purple {
            background-color: #ff00ff;
            border: 0.5vh solid #aa00aa;
        }
        #cyan {
            background-color: #00ffff;
            border: 0.5vh solid #00aaaa;
        }
        #white {
            background-color: #ffffff;
            border: 0.5vh solid #aaaaaa;
        }
        #black {
            background-color: #000000;
            border: 0.5vh solid #333333;
        }
        button:hover {
            transform: scale(1.1);
        }
        /*
        button:active {
            transform: scale(0.9);
            box-shadow: 0 0 1vh 1vh #000000;
        }*/
        #red:active {
            box-shadow: 0 0 1vh 1vh #aa0000;
        }
        #green:active {
            box-shadow: 0 0 1vh 1vh #00aa00;
        }
        #blue:active {
            box-shadow: 0 0 1vh 1vh #0000aa;
        }
        #yellow:active {
            box-shadow: 0 0 1vh 1vh #aaaa00;
        }
        #purple:active {
            box-shadow: 0 0 1vh 1vh #aa00aa;
        }
        #cyan:active {
            box-shadow: 0 0 1vh 1vh #00aaaa;
        }
        #white:active {
            box-shadow: 0 0 1vh 1vh #aaaaaa;
        }
        #black:active {
            box-shadow: 0 0 1vh 1vh #333333;
        }
        /*
        .selected {
            box-shadow: 0 0 0.5vh 0.5vh #000000;
        }*/
        #red.selected {
            box-shadow: 0 0 0.5vh 0.5vh #aa0000;
        }
        #green.selected {
            box-shadow: 0 0 0.5vh 0.5vh #00aa00;
        }
        #blue.selected {
            box-shadow: 0 0 0.5vh 0.5vh #0000aa;
        }
        #yellow.selected {
            box-shadow: 0 0 0.5vh 0.5vh #aaaa00;
        }
        #purple.selected {
            box-shadow: 0 0 0.5vh 0.5vh #aa00aa;
        }
        #cyan.selected {
            box-shadow: 0 0 0.5vh 0.5vh #00aaaa;
        }
        #white.selected {
            box-shadow: 0 0 0.5vh 0.5vh #aaaaaa;
        }
        #black.selected {
            box-shadow: 0 0 0.5vh 0.5vh #333333;
        }
        #colours {
            display: flex;
            flex-wrap: wrap;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="colours">
        <button onclick="selectColour(this)" id="red"></button>
        <button onclick="selectColour(this)" id="green"></button>
        <button onclick="selectColour(this)" id="blue"></button>
        <button onclick="selectColour(this)" id="yellow"></button>
        <button onclick="selectColour(this)" id="purple"></button>
        <button onclick="selectColour(this)" id="cyan"></button>
        <button onclick="selectColour(this)" id="white"></button>
        <button onclick="selectColour(this)" id="black"></button>
    </div>
    <!-- TODO: Add a timer to show the remaining time -->
    <canvas id="canvas"></canvas>
    <script>
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const x = Math.floor((mouseX / (tileSize * zoom)) + offsetX - Math.floor(canvas.width / (tileSize * zoom) / 2));
            const y = Math.floor((mouseY / (tileSize * zoom)) + offsetY - Math.floor(canvas.height / (tileSize * zoom) / 2));
            handleTileClick(x, y, e.clientX, e.clientY);
        });
        resizeCanvas();
        animate();
    </script>
</body>
</html>
